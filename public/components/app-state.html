<script src="../utils/Tools.js"></script>
<script src="../utils/AppData.js"></script>

<dom-module id="app-state">
  <script>
    class AppState extends IntertextMixin(Polymer.Element) {
      static get is() {
        return "app-state";
      }

      static get properties() {
        return {
          state: {
            type: Object,
            notify: true,
            value: () => ({})
          },
          initial: {
            type: Object,
            value: () => Tools.deepFreeze({
              session: {
                subscriptions: {}
              },
              persistent: {
                user: null
              }
            })
          },
          history: {
            type: Array,
            value: () => []
          },
          _frozen: {
            type: Boolean,
            value: true
          }
        }
      }

      static makeUser(nick, user) {
        return {
          name: nick,
          displayName: user.displayName,
          email: user.email,
          photo: user.photoURL,
          uid: user.uid
        }
      }

      getLatestVersion(username, project) {
        if (!username ||
          !project ||
          !Tools.testPath(this.state.persistent, ["users", username, "projects", project, "versions"])) {
          return -1;
        }
        let versions = this.state.persistent.users[username].projects[project].versions;
        return Object.keys(versions).map(n => Number(n)).sort((a, b) => b - a)[0];
      }

      connectedCallback() {
        super.connectedCallback();

        this._init({type: "state-init"});
        window.addEventListener('state-change-route', this._changeRoute.bind(this));          //select-project

        window.addEventListener('controller-auth-changed', this._authChanged.bind(this));
        window.addEventListener('controller-sign-in', this._signIn.bind(this));
        window.addEventListener('controller-sign-out', this._signOut.bind(this));
        window.addEventListener('controller-add-project', this._addProject.bind(this));
        window.addEventListener('controller-remove-project', this._removeProject.bind(this));
        window.addEventListener('controller-select-project', this._selectProject.bind(this));
        window.addEventListener('controller-select-version', this._selectVersion.bind(this));
//        window.addEventListener('controller-save-new-version', this._saveNewVersion.bind(this));
        window.addEventListener('controller-add-file', this._addFile.bind(this));
        window.addEventListener('controller-remove-file', this._removeFile.bind(this));
        window.addEventListener('controller-file-edited', this._fileEdited.bind(this));
        window.addEventListener('controller-current-project-changed', this._currentProjectChanged.bind(this));
        window.addEventListener('controller-new-projects', this._newProjects.bind(this));
        window.addEventListener('controller-new-versions', this._newVersions.bind(this));
      }

      _snap(action) {
        console.log(action, performance.now());
        const snap = {
          action: action,
          snapshot: this.state,
          timestamp: new Date().getTime(),
          apptime: performance.now()
        };
        this.set('history', [snap].concat(this.history));
      }

      _update(persistent, session, action) {
        this.set('state', {
          session: session,
          persistent: persistent
        });
        this._snap(action);
//        if (persistent)
//          this._store(persistent);
      }

      _store(state) {
        localStorage.setItem('state', JSON.stringify(state));
      }

      _getStored() {
        return Tools.deepFreeze(JSON.parse(localStorage.getItem('state')));
      }

      /**
       * INIT AND ROUTE
       */
      async _init(e) {
        let persistent = this.state.persistent || this._getStored() || this.initial.persistent;
        const session = Tools.mergeDeepWithNullToDelete(this.state.session, this.initial.session, this._frozen);
        this._update(persistent, session, 'state-init');
        firebase.auth().onAuthStateChanged((user) => this.$emit("controller-auth-changed", user));
      }

      async _changeRoute(e) {
        const route = e.detail.payload;

        const urlPage = route.segments[0];
        let currentProject = {
          owner: decodeURI(route.segments[1]),
          project: route.segments[2],
          version: Number(route.segments[3])
        };
        if (this.state.persistent.currentProject &&
          currentProject.owner === this.state.persistent.currentProject.owner &&
          currentProject.project === this.state.persistent.currentProject.project &&
          currentProject.version === this.state.persistent.currentProject.version &&
          this.state.persistent.currentProject.files )
          return;

        //"editor"
        if (urlPage === "editor") {
          if (!route.segments[2])                    //no selected project. Go home!!
            return this.$navigate("/home");

          const persistent = Tools.setIn(this.state.persistent, ['currentProject'], currentProject, this._frozen);
          //todo update the files to use the files we already have
          const session = Tools.setIn(this.state.session, ['route'], route, this._frozen);
          //check that the files are there and then load them if they are not..
          this._update(persistent, session, e.type);
          this.$emit("controller-current-project-changed");
        } else if (urlPage === "home") {
          const session = Tools.setIn(this.state.session, ['route'], route, this._frozen);
          this._update(this.state.persistent, session, e.type);
        } else {
          this.$navigate("/home");
        }
      }

      /**
       * USER AND LISTENING FOR logged in USERS PROJECTS
       */
      async _authChanged(e) {
        let user = e.detail.payload;
        if (user) {
          let userData = await AppData.getCurrentUserData(user.uid);  //wait for the nickname to load
          user = AppState.makeUser(userData.id, user);
        }
        let persistent = Tools.setIn(this.state.persistent, ['user'], user, this._frozen);
        this._update(persistent, this.state.session, e.type);
        this._updateProjectsListener(user ? user.name : null, e.type);
      }

      _signIn(e) {
        firebase.auth().signInWithPopup(new firebase.auth.GoogleAuthProvider());
      }

      _signOut(e) {
        firebase.auth().signOut();
      }

      _updateProjectsListener(username, action) {
        const existingSub = this.state.session.subscriptions.projects;
        if (existingSub === null && username === null)        //the same, null
          return;
        if (existingSub && existingSub.username === username) //the same, not null
          return;
        if (existingSub)
          existingSub.unsubscribe();

        let unsub = null;
        if (username) {
          const cb = ids => this.$emit("controller-new-projects", {username: username, ids: ids});
          unsub = {
            username: username,
            unsubscribe: AppData.listenToProjects(username, cb)
          };
        }
        const session = Tools.setIn(this.state.session, ['subscriptions', 'projects'], unsub, this._frozen);
        this._update(this.state.persistent, session, action);
      }

      /**
       * CURRENT PROJECT AND LISTENERS FOR VERSION
       */
      async _currentProjectChanged(e) {
        const currentProject = this.state.persistent.currentProject;
        if (this.state.persistent.user)
          AppData.setCurrentProject(this.state.persistent.user.name, this.state.persistent.currentProject);
        if (!currentProject)
          return this.$navigate("/home");

        let ownerName = currentProject.owner;
        let projectId = currentProject.project;
        let version = currentProject.version;
        this._updateVersionsListener(ownerName, projectId, e.type);

        if (!version) {
          let latest = this.getLatestVersion(ownerName, projectId);
          if (latest !== -1)
            this.$navigate(`/editor/${ownerName}/${projectId}/${latest}`);
          return;
        }
        let persistent = this.state.persistent;
        if (Tools.testPath(this.state.persistent, ["users", ownerName, "projects", projectId, "versions", version, "comment"])) {
          let comment = this.state.persistent.users[ownerName].projects [projectId].versions[version].comment;
          persistent = Tools.setIn(persistent, ['currentProject', 'versionComment'], comment, this._frozen);
        }
        if (this.state.persistent.currentProject &&
          ownerName === this.state.persistent.currentProject.owner &&
          projectId === this.state.persistent.currentProject.project &&
          version === this.state.persistent.currentProject.version &&
          this.state.persistent.currentProject.files )
          return;
        
        let files = await this._getFiles(ownerName, projectId, version);
        persistent = Tools.setIn(persistent, ['users', ownerName, 'projects', projectId, 'versions', version, 'files'], files, this._frozen);
        persistent = Tools.setIn(persistent, ['currentProject', 'files'], files, this._frozen);
        this._update(persistent, this.state.session, e.type);
      }

      _updateVersionsListener(ownerName, projectId, action) {
        const existingSub = this.state.session.subscriptions.versions;
        if (existingSub === null && ownerName === null)                             //the same, null
          return;
        if (existingSub && existingSub.owner === ownerName && existingSub.project === projectId)   //the same, not null
          return;
        if (existingSub)
          existingSub.unsubscribe();

        let unsub = null;
        if (ownerName && projectId) {
          const cb = ids => this.$emit("controller-new-versions", {
            owner: ownerName,
            project: projectId,
            versions: ids
          });
          unsub = {
            owner: ownerName,
            project: projectId,
            unsubscribe: AppData.listenToVersions(ownerName, projectId, cb)
          };
        }
        const session = Tools.setIn(this.state.session, ['subscriptions', 'versions'], unsub, this._frozen);
        this._update(this.state.persistent, session, action);
      }

      _newProjects(e) {
        let username = e.detail.payload.username;
        let projects = e.detail.payload.ids;
        const persistent = Tools.filterFirestore(this.state.persistent, ["users", username, "projects"], projects, this._frozen);
        this._update(persistent, this.state.session, e.type);
      }

      _newVersions(e) {
        let project = e.detail.payload.project;
        let owner = e.detail.payload.owner;
        let versionIds = e.detail.payload.versions;
        const persistent = Tools.filterFirestore(this.state.persistent, ["users", owner, "projects", project, "versions"], versionIds, this._frozen);
        this._update(persistent, this.state.session, e.type);
        this.$emit("controller-current-project-changed");
      }

      async _addProject(e) {
        const id = e.detail.payload;
        const user = this.state.persistent.user;
        await AppData.addProject(user.name, id);
        //todo update state directly by adding the project that was deleted from the state itself.
        //todo, maybe mark the object as newly created, green
      }

      async _selectProject(e) {
        const username = this.state.persistent.user.name;
        const id = e.detail.payload;
        this.$navigate(`/editor/${username}/${id}`);
      }

      async _selectVersion(e) {
        const project = e.detail.payload.project;
        const version = e.detail.payload.version;
        const owner = e.detail.payload.owner;
        this.$navigate(`/editor/${owner}/${project}/${version}`);
      }

      async _removeProject(e) {
        const id = e.detail.payload;
        const user = this.state.persistent.user;
        await AppData.removeProject(user, id);
        //todo update state directly by removing the project that was deleted from the state itself.
        //todo, maybe mark the object as newly deleted, orange
      }

      async _saveNewVersion() {
        let cp = this.state.persistent.currentProject;
//        let comment = e.detail.payload;
        //todo,this await is a little bad, we should lock the currentProject object here
        let nextVersion = await AppData.addVersion(cp.owner, cp.project, cp.files, "autosaved");
        let persistent = Tools.filterFirestore(this.state.persistent, ["users", cp.owner, "projects", cp.project, "versions", nextVersion], cp.files, this._frozen);
        persistent = Tools.setIn(this.state.persistent, ["currentProject", "version"], nextVersion);
        persistent = Tools.setIn(persistent, ["currentProject", "changed"], null);
        this._update(persistent, this.state.session, "autosave -> _saveNewVersion");
        this.$navigate(`/editor/${cp.owner}/${cp.project}/${nextVersion}`);
      }

      _fileEdited(e) {
        const filename = e.detail.payload.name;
        const value = e.detail.payload.value;
        let persistent = Tools.setIn(this.state.persistent, ["currentProject", "files", filename, "value"], value);
        persistent = Tools.setIn(persistent, ["currentProject", "changed"], new Date().getTime());
        this._update(persistent, this.state.session, e.type);
        this.$debounce(this._saveNewVersion.bind(this), 3000);
      }

      _addFile(e) {
        const filename = e.detail.payload.filename;
        const username = this.state.persistent.user.name;
        const ext = filename.split('.').pop();
        let value;
        if (ext === 'html')
          value = "<!-- created at " + new Date() + " by " + username + "-->"; //annoying bug in webstorm crashes on these backtick quotes
        else if (ext === 'css')
          value = `/* created at ${new Date()} by ${username} */`;
        else if (ext === 'js')
          value = `// created at ${new Date()} by ${username}`;
        let persistent = Tools.setIn(this.state.persistent, ["currentProject", "files", filename], {
          name: filename,
          value: value
        });
        persistent = Tools.setIn(persistent, ["currentProject", "changed"], new Date().getTime());
        this._update(persistent, this.state.session, e.type);
      }

      _removeFile(e) {
        const filename = e.detail.payload;
        const files = Object.assign({}, this.state.persistent.currentProject.files);
        delete files[filename];
        let persistent = Tools.setIn(this.state.persistent, ["currentProject", "files"], files, this._frozen);
        persistent = Tools.setIn(persistent, ["currentProject", "changed"], new Date().getTime());
        this._update(persistent, this.state.session, e.type);
      }

      async _getFiles(username, id, version) {
        if (Tools.testPath(this.state.persistent, ["users", username, "projects", id, "versions", version, "files"]))
          return this.state.persistent.users[username].projects[id].versions[version].files;
        return await AppData.getFiles(username, id, version);
      }
    }

    customElements.define(AppState.is, AppState);
  </script>
</dom-module>