<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="app-router.html">
<link rel="import" href="app-state.html">
<link rel="import" href="app-pages.html">
<link rel="import" href="app-iconset.html">
<link rel="import" href="app-db.html">

<dom-module id="app-shell">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>

    <app-state on-state-changed="_stateChanged"></app-state>
    <app-router default-url="home"></app-router>

    <app-db state="[[state]]"></app-db>

    <app-pages page="[[state.session.route.segments.0]]">
      <home-page page="home"
                 user="[[state.persistent.user]]"
                 user-data="[[_userObject]]">
      </home-page>
      <editor-page page="editor"
                   owner="[[state.session.route.segments.1]]"
                   project="[[state.session.route.segments.2]]"
                   version="[[state.session.actualVersion]]"
                   files="[[currentFiles]]"
                   versions="[[_projectObject.versions]]">
      </editor-page>
      <notfound-page page="notfound"></notfound-page>
    </app-pages>

  </template>
  <script>
    class AppShell extends IntertextMixin(Polymer.Element) {
      static get is() {
        return 'app-shell';
      }

      static get properties() {
        return {
          state: Object,
          history: Array,

          _userObject: {
            type: Object,
            computed: "_makeUserObject(state.persistent.user.name, state.persistent.users)"
          },
          _fullProjectObject: {
            type: Object,
            computed: "_makeProjectObject(state.session.route.segments.1, state.session.route.segments.2, state.persistent.users, state.session.edits)"
          },
          _projectObjectWithWorkingCopy: {
            type: Object,
            computed: "_makeProjectObjectWithWorkingCopy(_projectObject, state.session.edits)"
          }
        }
      }

      _stateChanged(e){
        this.set("state", e.detail.state);
        this.set("history", e.detail.history);
      }

      _makeUserObject(user, users) {
        if (this.$fullPathCheck("_MakeUserObject", [user, users]))
          return this._userObject;

        return (users && user) ? users[user] : undefined;
      }

      _fullProjectObject(owner, project, users, edits) {
        if (this.$fullPathCheck("_makeProjectObject", [owner, project, users, edits]))
          return this._projectObject;

        if (!owner || !project || !users || !Tools.testPath(users, [owner, "projects", project]))
          return undefined;
        let savedProject = users[owner].projects[project];
        if (!edits || !Tools.testPath(edits, [owner, "projects", project]))
          return savedProject;
        const latestVersionObjectFiles = savedProject.verisons[savedProject.latestVersion].files;
        const editsProject = edits[owner].projects[project];
        const workingCopyVersionFiles = editsProject.versions[workingCopy].files;
        if (workingCopyVersionFiles) {
          for (let filename in workingCopyVersionFiles) {
            if (workingCopyVersionFiles[filename].value === null)
              delete latestVersionObjectFiles[filename];
            else
              latestVersionObjectFiles[filename] = workingCopyVersionFiles[filename];
          }
        }
        return latestVersionObjectFiles;
      }

      _mergeCurrentFiles(edits, _versionObject) {
        if (this.$fullPathCheck("_mergeCurrentFiles", [edits, _versionObject]))
          return this.currentFiles;

        if (!_versionObject || !_versionObject.files)
          return undefined;
        let files = _versionObject.files;
        if (edits) {
          for (let filename in edits) {
            if (edits[filename].value === null)
              delete files[filename];
            else
              files[filename] = edits[filename];
          }
        }
        return files;
      }
    }

    customElements.define(AppShell.is, AppShell);
  </script>
</dom-module>