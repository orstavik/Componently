<script src="../utils/Tools.js"></script>
<script src="../utils/AppData.js"></script>

<dom-module id="app-state">
  <script>
    class AppState extends IntertextMixin(Polymer.Element) {
      static get is() {
        return "app-state";
      }

      static get properties() {
        return {
          state: {
            type: Object,
            notify: true,
            value: () => ({})
          },
          initial: {
            type: Object,
            value: () => ({
              session: {},
              persistent: {
                user: null,
                projects: []
              }
            })
          },
          history: {
            type: Array,
            value: () => []
          },
          _frozen: {
            type: Boolean,
            value: true
          }
        }
      }

      static makeUser(user) {
        return {
          name: user.displayName,
          email: user.email,
          photo: user.photoURL,
          uid: user.uid
        }
      }

      static getLatestVersion(versions) {
        let vs = Object.keys(versions).map(n => Number(n)).sort().reverse()[0];
        if (vs === undefined)
          throw new Error("no versions!");
        return vs;
      }

      connectedCallback() {
        super.connectedCallback();

        this._init({type: "state-init"});
        window.addEventListener('state-change-route', this._changeRoute.bind(this));          //select-project

        window.addEventListener('controller-check-user', this._checkUser.bind(this));
        window.addEventListener('controller-sign-in', this._signIn.bind(this));
        window.addEventListener('controller-sign-out', this._signOut.bind(this));
        window.addEventListener('controller-add-project', this._addProject.bind(this));
        window.addEventListener('controller-remove-project', this._removeProject.bind(this));
        window.addEventListener('controller-select-project', this._selectProject.bind(this));
        window.addEventListener('controller-select-version', this._selectVersion.bind(this));
        window.addEventListener('controller-add-file', this._addFile.bind(this));
      }

      _snap(action) {
        console.log(action, performance.now());
        const snap = {
          action: action,
          snapshot: this.state,
          timestamp: new Date().getTime(),
          apptime: performance.now()
        };
        this.set('history', [snap].concat(this.history));
      }

      _update(persistent, session, action) {
        this.set('state', {
          session: session,
          persistent: persistent
        });
        this._snap(action);
        if (persistent)
          this._store(persistent);
      }

      _store(state) {
        localStorage.setItem('state', JSON.stringify(state));
      }

      _getStored() {
        return JSON.parse(localStorage.getItem('state'));
      }

      async _init(e) {
        let persistent = this.state.persistent;
        if (!persistent) {
          const stored = this._getStored();
          if (stored) {
            persistent = Tools.deepFreeze(Object.assign(stored));
          } else {
            persistent = Tools.deepFreeze(Object.assign(this.initial.persistent))
          }
        }
        const session = Tools.mergeDeepWithNullToDelete(this.state.session, this.initial.session, this._frozen);
        this._update(persistent, session, 'state-init');
        await this._checkUser(e);
        this._getCurrentProjectVersion(e);
      }

      async _getCurrentProjectVersion(e) {
        const username = this.state.persistent.user.name;
        const userData = AppData.getCurrentUserData(username);
        let persistent = Tools.setIn(this.state.persistent, ['user', 'currentProject'], userData.currentProject, this._frozen);
        persistent = Tools.setIn(persistent, ['user', 'currentVersion'], userData.currentVersion, this._frozen);
        this._update(persistent, this.state.session, e.type);
      }


      async _changeRoute(e) {
        const route = e.detail.payload;
        //the route is the same project and the same version as before, should do nothing
        const urlPage = route.segments[0];
        let urlUserName = decodeURI(route.segments[1]);
        const urlProjectId = route.segments[2];
        const urlVersion = route.segments[3];
        let persistent = this.state.persistent;

        //if (asking for the same route as before)
        //  just return;??

        //"editor", but no selected project. Go home!!
        if (urlPage === "editor" && !urlProjectId)
          return this.$navigate("/home");

        //"editor" + project + version.
        else if (urlPage === "editor" && urlProjectId && urlVersion) {
          persistent = Tools.setIn(persistent, ['user', 'currentVersion'], urlVersion, this._frozen);
          AppData.setCurrentVersion(persistent.user.name, urlVersion); //await
          AppData.setCurrentProject(persistent.user.name, urlProjectId); //await
          //Ensure both versions and files are loaded
          let versionsPromise = this._getVersions(urlProjectId);
          let filesPromise = this._getFiles(urlProjectId, urlVersion);
          let files = await filesPromise, versions = await versionsPromise;
          persistent = Tools.setIn(persistent, ['projects', urlProjectId, 'versions'], versions, this._frozen);
          persistent = Tools.setIn(persistent, ['projects', urlProjectId, 'versions', urlVersion, 'files'], files, this._frozen);
        }

        //"editor" + project, but no version. Ensure versions are loaded, find latest version, and redirect.
        else if (urlPage === "editor" && urlProjectId && !urlVersion) {//only have project, not version
          persistent = Tools.setIn(persistent, ['user', 'currentProject'], urlProjectId, this._frozen);
          AppData.setCurrentProject(persistent.user.name, urlProjectId); //await
          //Ensure versions are loaded
          let versions = await this._getVersions(urlProjectId);
          persistent = Tools.setIn(persistent, ['projects', urlProjectId, 'versions'], versions, this._frozen);
          let latest = AppState.getLatestVersion(versions);
          return this.$navigate(`/editor/${urlUserName}/${urlProjectId}/${latest}`);
        }

        const session = Tools.setIn(this.state.session, ['route'], route, this._frozen);
        //check that the files are there and then load them if they are not..
        this._update(persistent, session, e.type);
      }

      _checkUser(e) {
        return new Promise((resolve, reject) => {
          firebase.auth().onAuthStateChanged(async (user) => {
            if (user) {
              user = AppState.makeUser(user);
              const persistent = Tools.setIn(this.state.persistent, ['user'], user, this._frozen);
              this._update(persistent, this.state.session, e.type);
              await this._getProjects(e);
            } else {
              let persistent = Tools.setIn(this.state.persistent, ['user'], null, this._frozen);
              persistent = Tools.setIn(persistent, ['projects'], [], this._frozen);
              this._update(persistent, this.state.session, e.type);
            }
            resolve();
          })
        });
      }

      _signIn(e) {
        firebase.auth().signInWithPopup(new firebase.auth.GoogleAuthProvider())
          .then((result) => {
            let user = AppState.makeUser(result.user);
            const persistent = Tools.setIn(this.state.persistent, ['user'], user, this._frozen);
            this._update(persistent, this.state.session, e.type);
            this._getProjects(e);
          });
      }

      _signOut(e) {
        firebase.auth().signOut()
          .then(() => {
            let persistent = Tools.setIn(this.state.persistent, ['user'], null, this._frozen);
            persistent = Tools.setIn(persistent, ['projects'], [], this._frozen);
            this._update(persistent, this.state.session, e.type);
          })
      }

      async _getProjects(e) {
        if (this.state.persistent.projects)
          return;
        const projects = await AppData.getProjects(this.state.persistent.user);
        const persistent = Tools.setIn(this.state.persistent, ['projects'], projects, this._frozen);
        this._update(persistent, this.state.session, e.type);
      }

      async _getVersions(id) {
        const projects = this.state.persistent.projects;
        if (projects[id] && projects[id].versions)
          return projects[id].versions;
        return await AppData.getVersions(this.state.persistent.user, id);
      }

      async _addProject(e) {
        const id = e.detail.payload;
        const user = this.state.persistent.user;
        await AppData.addProject(user.name, id);
        this._getProjects(e);
        //todo update state directly by adding the project that was deleted from the state itself.
      }

      async _selectProject(e) {
        const username = this.state.persistent.user.name;
        const id = e.detail.payload;
        this.$navigate(`/editor/${username}/${id}`);
      }

      async _selectVersion(e) {
        const id = e.detail.payload.id;
        const version = e.detail.payload.version;
        const username = this.state.persistent.user.name;
        this.$navigate(`/editor/${username}/${id}/${version}`);
      }

      async _removeProject(e) {
        const id = e.detail.payload;
        const user = this.state.persistent.user;
        await AppData.removeProject(user, id);
        //await this._getProjects(e);
        //todo update state directly by removing the project that was deleted from the state itself.
      }

      async _addFile(e) {
        const user = this.state.persistent.user;
        const id = e.detail.payload.id;
        const version = e.detail.payload.version;
        const filename = e.detail.payload.filename;
        await AppData.addFile(user.name, id, version, filename);
        //this._getProjects(e);
        //todo update state directly by adding the file that was deleted from the state itself.
      }

      async _getFiles(id, version) {
        const user = this.state.persistent.user;
        const projects = this.state.persistent.user.projects;
        if (projects && projects[id] && projects[id].versions && projects[id].versions[version] && projects[id].versions[version].files)
          return projects[id].versions[version].files;
        return await AppData.getFiles(user, id, version);
      }
    }

    customElements.define(AppState.is, AppState);
  </script>
</dom-module>