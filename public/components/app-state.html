<script src="../utils/Tools.js"></script>

<dom-module id="app-state">
  <script>
    class AppState extends IntertextMixin(Polymer.Element) {
      static get is() {
        return "app-state";
      }

      static get properties() {
        return {
          state: {
            type: Object,
            notify: true,
            value: () => ({})
          },
          initial: {
            type: Object,
            value: () => ({
              session: {},
              persistent: {
                user: null,
                projects: []
              }
            })
          },
          history: {
            type: Array,
            value: () => []
          },
          _frozen: {
            type: Boolean,
            value: true
          }
        }
      }

      static makeUser(user) {
        return {
          name: user.displayName,
          email: user.email,
          photo: user.photoURL,
          uid: user.uid
        }
      }

      static deleteCollection(db, collectionRef, batchSize) {
        batchSize = batchSize || 3;
        const query = collectionRef.orderBy('__name__').limit(batchSize);

        function deleteQueryBatch(db, query, batchSize, resolve, reject) {
          query.get()
            .then((snapshot) => {
              // When there are no documents left, we are done
              if (snapshot.size == 0) {
                return 0;
              }
              // Delete documents in a batch
              const batch = db.batch();
              snapshot.docs.forEach((doc) => {
                batch.delete(doc.ref);
              });
              return batch.commit().then(() => snapshot.size);
            })
            .then(function (numDeleted) {
              if (numDeleted <= batchSize) {
                resolve();
                return;
              }
              // Recurse on the next process tick, to avoid
              // exploding the stack.
              process.nextTick(() => deleteQueryBatch(db, query, batchSize, resolve, reject));
            })
            .catch(reject);
        }
        return new Promise((resolve, reject) => {
          deleteQueryBatch(db, query, batchSize, resolve, reject);
        })
      }

      connectedCallback() {
        super.connectedCallback();

        this._init();
        window.addEventListener('state-change-route', this._changeRoute.bind(this));
        window.addEventListener('state-user-in', this._userIn.bind(this));
        window.addEventListener('state-user-out', this._userOut.bind(this));
        window.addEventListener('state-user-projects', this._userProjects.bind(this));
        window.addEventListener('state-project-versions', this._projectVersions.bind(this));
        window.addEventListener('state-version-files', this._versionFiles.bind(this));

        window.addEventListener('controller-check-user', this._checkUser.bind(this));
        window.addEventListener('controller-sign-in', this._signIn.bind(this));
        window.addEventListener('controller-sign-out', this._signOut.bind(this));
        window.addEventListener('controller-get-versions', this._getVersions.bind(this));
        window.addEventListener('controller-add-project', this._addProject.bind(this));
        window.addEventListener('controller-remove-project', this._removeProject.bind(this));
        window.addEventListener('controller-get-files', this._getFiles.bind(this));
      }

      _snap(action) {
        console.log(action, performance.now());
        const snap = {
          action: action,
          snapshot: this.state,
          timestamp: new Date().getTime(),
          apptime: performance.now()
        };
        this.set('history', [snap].concat(this.history));
      }

      _update(persistent, session, action) {
        this.set('state', {
          session: session,
          persistent: persistent
        });
        this._snap(action);
        if (persistent)
          this._store(persistent);
      }

      _store(state) {
        localStorage.setItem('state', JSON.stringify(state));
      }

      _getStored() {
        return JSON.parse(localStorage.getItem('state'));
      }

      _init(e) {
        let persistent = this.state.persistent;
        if (!persistent) {
          const stored = this._getStored();
          if (stored) {
            persistent = Tools.deepFreeze(Object.assign(stored));
          } else {
            persistent = Tools.deepFreeze(Object.assign(this.initial.persistent))
          }
        }
        const session = Tools.mergeDeepWithNullToDelete(this.state.session, this.initial.session, this._frozen);
        this._update(persistent, session, 'state-init');
        this._checkUser();
      }

      _changeRoute(e) {
        const route = e.detail.payload;
        // if (route.segments[0] === 'editor' && route.segments[1]) {
        //   let projectId = route.segments[1];
          
        //   if (!this.state.persistent.projects[projectId].versions)
        //     this._getVersions({
        //       detail: {
        //         payload: projectId
        //       }
        //     }).then(() => {
        //       let version = route.segments[2] || this.state.persistent.projects[projectId].versions
        //     });
        // }
        const session = Tools.setIn(this.state.session, ['route'], route, this._frozen);
        this._update(this.state.persistent, session, e.type);
      }

      _userIn(e) {
        const user = e.detail.payload;
        const persistent = Tools.setIn(this.state.persistent, ['user'], user, this._frozen);
        this._update(persistent, this.state.session, e.type);
      }

      _userOut(e) {
        const persistent = Tools.setIn(this.state.persistent, ['user'], null, this._frozen);
        this._update(persistent, this.state.session, e.type);
      }

      _userProjects(e) {
        const projects = e.detail.payload;
        const persistent = Tools.setIn(this.state.persistent, ['projects'], projects, this._frozen);
        this._update(persistent, this.state.session, e.type);
      }

      _projectVersions(e) {
        const id = e.detail.payload.id;
        const versions = e.detail.payload.versions;
        const persistent = Tools.setIn(this.state.persistent, ['projects', id, 'versions'], versions, this._frozen);
        this._update(persistent, this.state.session, e.type);
      }

      _versionFiles(e) {
        const id = e.detail.payload.id;
        const version = e.detail.payload.version;
        const files = e.detail.payload.files;
        const persistent = Tools.setIn(this.state.persistent, ['projects', id, 'versions', version, 'files'], files,
          this._frozen);
        this._update(persistent, this.state.session, e.type);
      }

      _checkUser() {
        firebase.auth().onAuthStateChanged((user) => {
          if (user) {
            user = AppState.makeUser(user);
            this.$commit('state-user-in', user, '_userIn');
            this._getProjects();
          } else {
            this.$commit('state-user-out', null, '_userOut');
            this.$commit('state-user-projects', [], '_userProjects');
          }
        });
      }

      _signIn() {
        firebase.auth().signInWithPopup(new firebase.auth.GoogleAuthProvider())
          .then((result) => {
            let user = AppState.makeUser(result.user);
            this.$commit('state-user-in', user, '_userIn');
            this._getProjects();
          });
      }

      _signOut() {
        firebase.auth().signOut()
          .then(() => {
            this.$commit('state-user-out', null, '_userOut');
            this.$commit('state-user-projects', [], '_userProjects');
          })
      }

      _getProjects() {
        const db = firebase.firestore();
        const user = this.state.persistent.user;
        db.collection(`users/${user.name}/projects`).get()
          .then((querySnap) => {
            const projects = {};
            querySnap.docs.forEach((doc) => {
              projects[doc.id] = {};
            });
            this.$commit('state-user-projects', projects, '_userProjects');
          });
      }

      _getVersions(e) {
        return new Promise((resolve, reject) => {
          const id = e.detail.payload;
          const user = this.state.persistent.user;
          const db = firebase.firestore();
          db.collection(`users/${user.name}/projects/${id}/versions`).orderBy('name', 'desc').get()
            .then((querySnap) => {
              const versions = {};
              querySnap.docs.forEach((doc) => {
                versions[doc.id] = {};
              });
              resolve();
            });
        });
      }

      _addProject(e) {
        const id = e.detail.payload;
        const db = firebase.firestore();
        const user = this.state.persistent.user;
        db.doc(`users/${user.name}/projects/${id}`).set({
          name: id
        }).then((snap) => {
          this._getProjects();
        });
      }

      _removeProject(e) {
        const id = e.detail.payload;
        const db = firebase.firestore();
        const user = this.state.persistent.user;
        const deleteDoc = db.doc(`users/${user.name}/projects/${id}`).delete();
        const deleteCollections = AppState.deleteCollection(db, db.collection(
          `users/${user.name}/projects/${id}/versions`));
        Promise.all([deleteDoc, deleteCollections])
          .then(() => {
            this._getProjects();
          });
      }

      _getFiles(e) {
        const db = firebase.firestore();
        const id = e.detail.payload.id;
        const version = e.detail.payload.version;
        const user = this.state.persistent.user;
        db.collection(`users/${user.name}/projects/${id}/versions/${version}/files`).get()
          .then((querySnap) => {
            const files = {};
            querySnap.docs.forEach((doc) => {
              files[doc.id] = doc.data();
            });
            this.$commit('state-version-files', {
              id: id,
              version: version,
              files: files
            }, '_versionFiles');
          });
      }
    }
    customElements.define(AppState.is, AppState);
  </script>
</dom-module>