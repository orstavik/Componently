<script src="../utils/Tools.js"></script>
<script src="../utils/AppData.js"></script>

<dom-module id="app-state">
  <script>
    class AppState extends IntertextMixin(Polymer.Element) {
      static get is() {
        return "app-state";
      }

      static get properties() {
        return {
          state: {
            type: Object,
            notify: true,
            value: () => ({})
          },
          initial: {
            type: Object,
            value: () => Tools.deepFreeze({
              session: {
                subscriptions: {}
              },
              persistent: {
                user: null
              }
            })
          },
          history: {
            type: Array,
            value: () => []
          }
        }
      }

      static makeUser(nick, user) {
        return {
          name: nick,
          displayName: user.displayName,
          email: user.email,
          photo: user.photoURL,
          uid: user.uid
        }
      }

      static getLatestVersionNumber(persistent, username, project) {
        if (!username ||
          !project ||
          !Tools.testPath(persistent, ["users", username, "projects", project, "versions"])) {
          return undefined;
        }
        let versions = persistent.users[username].projects[project].versions;
        return Object.keys(versions).map(n => Number(n)).sort((a, b) => b - a)[0];
      }

      connectedCallback() {
        super.connectedCallback();

        this._init({type: "state-init"});
        window.addEventListener('state-change-route', this._changeRoute.bind(this));          //select-project

        //auth
        window.addEventListener('controller-auth-changed', this._authChanged.bind(this));
        window.addEventListener('controller-sign-in', this._signIn.bind(this));
        window.addEventListener('controller-sign-out', this._signOut.bind(this));
        //user
        window.addEventListener('controller-add-project', this._addProject.bind(this));
        window.addEventListener('controller-remove-project', this._removeProject.bind(this));
        window.addEventListener('controller-select-project', this._selectProject.bind(this));
        window.addEventListener('controller-select-version', this._selectVersion.bind(this));
        window.addEventListener('controller-add-file', this._addFile.bind(this));
        window.addEventListener('controller-remove-file', this._removeFile.bind(this));
        window.addEventListener('controller-file-edited', this._fileEdited.bind(this));
        //db
        window.addEventListener('controller-new-projects', this._newProjects.bind(this));
        window.addEventListener('controller-new-versions', this._newVersions.bind(this));
        window.addEventListener('controller-new-files', this._newFiles.bind(this));
        window.addEventListener('controller-new-version-subscription', this._newVersionSubscription.bind(this));
        window.addEventListener('controller-new-projects-subscription', this._newProjectsSubscription.bind(this));
      }

      _snap(action) {
        console.log(action, performance.now());
        const snap = {
          action: action,
          snapshot: this.state,
          timestamp: new Date().getTime(),
          apptime: performance.now()
        };
        this.set('history', [snap].concat(this.history));
      }

      _update(persistent, session, action) {
        this.set('state', {
          session: session,
          persistent: persistent
        });
        this._snap(action);
//        if (persistent)
//          this._store(persistent);
      }

      _store(state) {
        localStorage.setItem('state', JSON.stringify(state));
      }

      _getStored() {
        return Tools.deepFreeze(JSON.parse(localStorage.getItem('state')));
      }

      /**
       * INIT AND ROUTE
       */
      async _init(e) {
        let persistent = this.state.persistent || this._getStored() || this.initial.persistent;
        const session = Tools.mergeDeepWithNullToDelete(this.state.session, this.initial.session);
        this._update(persistent, session, 'state-init');
        firebase.auth().onAuthStateChanged((user) => this.$emit("controller-auth-changed", user));
//        firebase.auth().onAuthStateChanged(this._authChanged.bind(this));
      }

      async _changeRoute(e) {
        const newR = e.detail.payload.segments;
        if (this.state.session.route) {
          const oldR = this.state.session.route.segments;
          if (newR[0] === oldR[0] && newR[1] === oldR[1] && newR[2] === oldR[2] && newR[3] === oldR[3])
            return;
        }
        //check for invalid route, and if so, redirect /home
        if (newR[0] === "editor" && !newR[2])
          return this.$navigate("/home/" + newR[1]);

        let session = Tools.setIn(this.state.session, ['route'], e.detail.payload);

        let actualVersion = newR[3];
        if (!actualVersion)
          actualVersion = AppState.getLatestVersionNumber(this.state.persistent, newR[1], newR[2]);
        session = Tools.setIn(session, ['actualVersion'], actualVersion);

        this._update(this.state.persistent, session, e.type);
      }

      /**
       * AUTH
       */
      async _authChanged(e/*user*/) {
        let user = e.detail.payload;
        if (user) {
          let userData = await AppData.getCurrentUserData(user.uid);  //wait for the nickname to load
          user = AppState.makeUser(userData.id, user);
        }
        let persistent = Tools.setIn(this.state.persistent, ['user'], user);
        this._update(persistent, this.state.session, e.type);
      }

      _signIn(e) {
        firebase.auth().signInWithPopup(new firebase.auth.GoogleAuthProvider());//.then(this._authChanged.bind(this));
      }

      _signOut(e) {
        firebase.auth().signOut();//.then(this._authChanged.bind(this));
      }

      /**
       * DB INITIATED EVENTS
       */
      _newVersionSubscription(e) {
        let unsub = e.detail.payload;
        const session = Tools.setIn(this.state.session, ['subscriptions', 'versions'], unsub);
        this._update(this.state.persistent, session, e.type);
      }

      _newProjectsSubscription(e) {
        let unsub = e.detail.payload;
        const session = Tools.setIn(this.state.session, ['subscriptions', 'projects'], unsub);
        this._update(this.state.persistent, session, e.type);
      }

      _newProjects(e) {
        let username = e.detail.payload.username;
        let projects = e.detail.payload.ids;
        const persistent = Tools.filterFirestore(this.state.persistent, ["users", username, "projects"], projects);
        this._update(persistent, this.state.session, e.type);
      }

      _newVersions(e) {
        let project = e.detail.payload.project;
        let owner = e.detail.payload.owner;
        let versionsShallow = e.detail.payload.versions;
        let persistent = Tools.filterFirestore(this.state.persistent, ["users", owner, "projects", project, "versions"], versionsShallow);
        this._update(persistent, this.state.session, e.type);

        const segments = this.state.session.route.segments;
        if (segments[3] || segments[1] !== owner || segments[2] !== project)
          return;
        let actualVersion = AppState.getLatestVersionNumber(this.state.persistent, segments[1], segments[2]);
        let session = Tools.setIn(this.state.session, ['actualVersion'], actualVersion);
        this._update(this.state.persistent, session, e.type);
      }

      _newFiles(e) {
        let owner = e.detail.payload.owner;
        let project = e.detail.payload.project;
        let version = e.detail.payload.version;
        let files = e.detail.payload.files;
        let persistent = Tools.setIn(this.state.persistent, ['users', owner, 'projects', project, 'versions', version, 'files'], files);
        this._update(persistent, this.state.session, e.type);


//        debugger;
        //todo here we should test if the new files are the same as the editFiles,
        //todo and if so update version and remove the parts of the editFiles from the
        //todo if there are no conflict, only other files that are updated,
        //todo then the version we are working on can be updated seamlessly.
        if (
          this.state.session.route.segments[1] === owner &&
          this.state.session.route.segments[1] === project &&
          this.state.session.actualVersion < version &&
          this.state.session.edits
        ) {
          let newEdits = Object.assign({}, this.state.session.edits);

        }
        //todo remove from edits if the update file(s) are the same as the edits
//        let cp = this.state.persistent.currentProject;
//        if (cp.owner !== res.owner || cp.project !== res.project)
//          return;
//
//        let latestVersion = AppState.getLatestVersionNumber(this.state.persistent, cp.owner, cp.project);
//        if ((cp.version && cp.version === res.version) || (latestVersion === res.version)) {
//          persistent = Tools.setIn(persistent, ['currentProject', 'files'], res.files);
//          persistent = Tools.setIn(persistent, ['currentProject', 'actualVersion'], res.version);
//          this._update(persistent, this.state.session, e.type);
//        }
      }

      /**
       * USER INITIATED EVENTS
       */
      async _selectProject(e) {
        const username = this.state.persistent.user.name;
        const id = e.detail.payload;
        this.$navigate(`/editor/${username}/${id}`);
      }

      async _selectVersion(e) {
        const project = e.detail.payload.project;
        const version = e.detail.payload.version;
        const owner = e.detail.payload.owner;
        this.$navigate(`/editor/${owner}/${project}/${version}`);
      }

      async _addProject(e) {
        const id = e.detail.payload;
        const user = this.state.persistent.user;
        await AppData.addProject(user.name, id);
        //todo update state directly by adding the project that was deleted from the state itself.
        //todo, maybe mark the object as newly created, green
      }

      async _removeProject(e) {
        const id = e.detail.payload;
        const user = this.state.persistent.user;
        await AppData.removeProject(user, id);
        //todo update state directly by removing the project that was deleted from the state itself.
        //todo, maybe mark the object as newly deleted, orange
      }

      _fileEdited(e) {
        const filename = e.detail.payload.name;
        const value = e.detail.payload.value;
        const owner = this.state.session.route.segments[1];
        const project = this.state.session.route.segments[2];
        let session = Tools.setIn(this.state.session, ["edits", owner, "projects", project, "versions", "workingCopy", "files", filename], {
          name: filename,
          value: value,
          timestamp: new Date().getTime()
        });
        this._update(this.state.persistent, session, e.type);
      }

      _addFile(e) {
        const filename = e.detail.payload.filename;
        const username = this.state.persistent.user.name;
        const owner = this.state.session.route.segments[1];
        const project = this.state.session.route.segments[2];
        let session = Tools.setIn(this.state.session, ["edits", owner, "projects", project, "versions", "workingCopy", "files", filename], {
          name: filename,
          value: AppState.getDefaultText(filename, username),
          timestamp: new Date().getTime()
        });
        this._update(this.state.persistent, session, e.type);
//        let makeView = AppState.makeView(this.state.persistent.edits, this.state.persistent.currentProject, this.state.persistent.users);
//        persistent = Tools.setIn(persistent, ["view"], makeView);
      }

      _removeFile(e) {
        const filename = e.detail.payload;
        const owner = this.state.session.route.segments[1];
        const project = this.state.session.route.segments[2];
        let session = Tools.setIn(this.state.session, ["edits", owner, "projects", project, "versions", "workingCopy", "files", filename], null);
        this._update(this.state.persistent, session, e.type);
      }

      static getDefaultText(filename, username) {
        const ext = filename.split('.').pop();
        if (ext === 'html')
          return "<!-- created at " + new Date() + " by " + username + "-->"; //annoying bug in webstorm crashes on these backtick quotes
        if (ext === 'css')
          return `/* created at ${new Date()} by ${username} */`;
        if (ext === 'js')
          return `// created at ${new Date()} by ${username}`;
      }
    }

    customElements.define(AppState.is, AppState);
  </script>
</dom-module>