<dom-module id="resizable-boxes">
  <template>
    <style>
      :host {
        display: flex;
        position: relative;
      }
      #grid {
        display: grid;
        height: 100%;
      }
      #grid.unselectable ::slotted(*) {
        user-select: none;
      }
      ::slotted(.separator) {
        display: inline-block;
        background-color: black;
        cursor: col-resize;
      }
    </style>

    <div id="grid">
      <slot id="slot"></slot>
    </div>

  </template>
  <script>
    class ResizableBoxes extends Polymer.GestureEventListeners(IntertextMixin(Polymer.Element)) {
      static get is() {
        return 'resizable-boxes';
      }

      static get properties() {
        return {
          _boxes: {
            type: Array,
            value: () => [],
            observer: '_boxesChange'
          },
          _gridColumns: {
            type: Array,
            value: () => []
          }
        }
      }

      connectedCallback() {
        super.connectedCallback();
        setTimeout(() => {
          this.set('_boxes', this._detectBoxes());
        }, 0);
        this.$.slot.addEventListener('slotchange', (e) => {
          this.set('_boxes', this._detectBoxes());
        });
      }

      _boxesChange() {
        this._makeGridColumns();
        this._makeSeparators();
      }

      _detectBoxes() {
        return this.$.slot.assignedNodes().filter((node) => {
          return node.nodeType === 1 && ['dom-repeat','template'].indexOf(node.localName) === -1 && !node.classList.contains('separator')
        });
      }

      _makeGridColumns() {
        this._gridColumns = this._boxes.map((node, i) => this._gridColumns[i] || 1);
        this._applyStyle();
      }

      _makeSeparators() {
        if (this._boxes.length > 1) {
          const divTemplate = document.createElement('div');
          divTemplate.classList.add('separator');
          for (let i = 1; i < this._boxes.length; i++) {
            let box = this._boxes[i];
            if (!box.previousElementSibling.classList.contains('separator')) {
              let div = divTemplate.cloneNode();
              Polymer.Gestures.addListener(div, 'track', (e) => {
                this._separatorDraged(e);
              });
              this.insertBefore(div, box);
            }
          }
        } else {
          this.querySelectorAll('.separator').forEach((sep) => sep.remove());
        }
        const lastBox = this._boxes[this._boxes.length-1];
        if (lastBox && lastBox.nextElementSibling.classList.contains('separator'))
          lastBox.nextElementSibling.remove()
      }

      _separatorDraged(e) {
        if (e.detail.state === 'start')
          this.$.grid.classList.add('unselectable');
        if (e.detail.state === 'end') {
          this.$.grid.classList.remove('unselectable');
          this._refreshEditors();
        }
        const ddx = e.detail.ddx !== undefined ? e.detail.ddx : e.detail.dx;
        const ddy = e.detail.ddy !== undefined ? e.detail.ddy : e.detail.dy;
        const width = this.getBoundingClientRect().width;
        const n = this._gridColumns.length;
        const fr = (width-((n-1)*6))/n;
        const px = ddx/fr;
        const py = ddy/fr;
        const prevBox = e.srcElement.previousElementSibling;
        const nextBox = e.srcElement.nextElementSibling;
        const prevIndex = this._boxes.indexOf(prevBox);
        const nextIndex = this._boxes.indexOf(nextBox);
        const frSum = this._gridColumns[prevIndex] + this._gridColumns[nextIndex];
        this._gridColumns[prevIndex] += px;
        this._gridColumns[nextIndex] -= px;
        if (this._gridColumns[prevIndex] < 120/fr) {
          this._gridColumns[prevIndex] = 120/fr;
          this._gridColumns[nextIndex] = frSum - 120/fr;
        }
        if (this._gridColumns[nextIndex] < 120/fr) {
          this._gridColumns[nextIndex] = 120/fr;
          this._gridColumns[prevIndex] = frSum - 120/fr;
        }
        this._applyStyle();
      }

      _applyStyle() {
        let gridColumns = '';
        for (let i = 0; i < this._gridColumns.length; i++) {
          gridColumns += `minmax(120px, ${this._gridColumns[i]}fr)`;
          if (i < this._boxes.length-1)
            gridColumns += ' 6px ';
        }
        this.$.grid.style.gridTemplateColumns = gridColumns;
      }

      _refreshEditors() {
        for (let box of this._boxes)
          box.editor.refresh();
      }
    }
    customElements.define(ResizableBoxes.is, ResizableBoxes);
  </script>
</dom-module>